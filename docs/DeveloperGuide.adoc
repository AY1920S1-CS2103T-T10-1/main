= AddressBook Level 3 - Developer Guide
:nus-mods-api: https://api.nusmods.com/v2/
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/se-edu/addressbook-level3/tree/master

By: `Team SE-EDU`      Since: `Jun 2016`      Licence: `MIT`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command
image::ArchitectureSequenceDiagram.png[]

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `JarvisParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteAddressCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* Stores the History Manager data.
* Stores the Finance Tracker data
* Stores the Cca Tracker Data
* Stores the Course Planner Data
* Stores the Planner data
* Does not depend on any of the other three components.

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book, History Manager, Finance Tracker, Cca Tracker, Course Planner and Planner
data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.jarvis.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
=== [Proposed] Undo/Redo feature
==== Proposed Implementation

The undo/redo mechanism is facilitated by `VersionedAddressBook`.
It extends `AddressBook` with an undo/redo history, stored internally as an `addressBookStateList` and `currentStatePointer`.
Additionally, it implements the following operations:

* `VersionedAddressBook#commit()` -- Saves the current address book state in its history.
* `VersionedAddressBook#undo()` -- Restores the previous address book state from its history.
* `VersionedAddressBook#redo()` -- Restores a previously undone address book state from its history.

These operations are exposed in the `Model` interface as `Model#commitAddressBook()`, `Model#undoAddressBook()` and `Model#redoAddressBook()` respectively.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

Step 1. The user launches the application for the first time. The `VersionedAddressBook` will be initialized with the initial address book state, and the `currentStatePointer` pointing to that single address book state.

image::UndoRedoState0.png[]

Step 2. The user executes `delete 5` command to delete the 5th person in the address book. The `delete` command calls `Model#commitAddressBook()`, causing the modified state of the address book after the `delete 5` command executes to be saved in the `addressBookStateList`, and the `currentStatePointer` is shifted to the newly inserted address book state.

image::UndoRedoState1.png[]

Step 3. The user executes `add n/David ...` to add a new person. The `add` command also calls `Model#commitAddressBook()`, causing another modified address book state to be saved into the `addressBookStateList`.

image::UndoRedoState2.png[]

[NOTE]
If a command fails its execution, it will not call `Model#commitAddressBook()`, so the address book state will not be saved into the `addressBookStateList`.

Step 4. The user now decides that adding the person was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undoAddressBook()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous address book state, and restores the address book to that state.

image::UndoRedoState3.png[]

[NOTE]
If the `currentStatePointer` is at index 0, pointing to the initial address book state, then there are no previous address book states to restore. The `undo` command uses `Model#canUndoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

The following sequence diagram shows how the undo operation works:

image::UndoSequenceDiagram.png[]

NOTE: The lifeline for `UndoCommand` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

The `redo` command does the opposite -- it calls `Model#redoAddressBook()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the address book to that state.

[NOTE]
If the `currentStatePointer` is at index `addressBookStateList.size() - 1`, pointing to the latest address book state, then there are no undone address book states to restore. The `redo` command uses `Model#canRedoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

Step 5. The user then decides to execute the command `list`. Commands that do not modify the address book, such as `list`, will usually not call `Model#commitAddressBook()`, `Model#undoAddressBook()` or `Model#redoAddressBook()`. Thus, the `addressBookStateList` remains unchanged.

image::UndoRedoState4.png[]

Step 6. The user executes `clear`, which calls `Model#commitAddressBook()`. Since the `currentStatePointer` is not pointing at the end of the `addressBookStateList`, all address book states after the `currentStatePointer` will be purged. We designed it this way because it no longer makes sense to redo the `add n/David ...` command. This is the behavior that most modern desktop applications follow.

image::UndoRedoState5.png[]

The following activity diagram summarizes what happens when a user executes a new command:

image::CommitActivityDiagram.png[]

==== Design Considerations

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire address book.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.

===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use a list to store the history of address book states.
** Pros: Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `VersionedAddressBook`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate list, and just reuse what is already in the codebase.
** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things.

=== Undo/Redo Feature
==== Overview
The application should be able to undo and redo changes made by commands to give the user more flexibility in their inputs.
Undo and redo operations should also be undo or redo multiple commands in a command.
In the event that a undo/redo command that comprises of multiple undo/redo operations fails at any point, all changes made
by the command should be rolled back. This is reflected in the Activity Diagram below:

.Activity Diagram for undo and redo commands
image::UndoRedoActivityDiagram.png[]

Therefore there is a need to remember commands that change the state of the `Model`. Commands that just render a view without
actually changing the application should not be stored as it does not make sense to undo or redo them.
We will distinguish these types of commands into two categories, *invertible commands* and *non-invertible commands*.

* *Invertible commands* -- commands that mutate the state of the `Model` and should be stored for undo/redo functions.
* *Non-invertible commands* -- commands that do not mutate the state of the `Model` and should not be stored for undo/redo functions.

[NOTE]
Undo and redo commands will be considered non-invertible commands even though they technically change the state of the `Model`.
The reason is that they are commands facilitating the undo and redo operation, thus they should not be stored.

The following activity diagram illustrates how commands are remembered when a user types in a command:

.Activity Diagram for how commands are remembered after their successful execution
image::CommandActivityDiagram.png[]

==== Implementation
The undo/redo feature mechanism is facilitated by `HistoryManager`. `HistoryManager` remembers *invertible commands*. These commands are stored internally in
two `CommandDeque` objects, `executedCommands` and `inverselyExecutedCommands`. `CommandDeque` serve as custom `Deque`
data structure, which stores the latest added command to the top.

An undo operation would comprise of taking the latest executed command from `executedCommands`, inversely executing it, and adding it to
`inverselyExecutedCommands`. A redo operation would comprise of a taking the latest inversely executed command from
`inverselyExecutedCommands`, executing it, and adding it to `executedCommands`.

`Model` supports operations to facilitate
undo and redo capabilities by extending the `HistoryModel` which has the following operations:

* `Model#getHistoryManager()` -- Gets the `HistoryManager` instance.
* `Model#setHistoryManager(HistoryManager)` -- Resets the `HistoryManager` data to the given `HistoryManager` in the argument.
* `Model#getAvailableNumberOfExecutedCommands()` -- Gets the maximum available number of commands that can be undone.
* `Model#getAvailableNumberOfInverselyExecutedCommands()` -- Gets the maximum available number of commands that can be redone.
* `Model#canRollback()` -- Checks if it is possible to undo a command at the given state.
* `Model#canCommit()` -- Checks if it is possible to redo a command at the given state.
* `Model#rememberExecutedCommand(Command)` -- Remembers the given `Command` and stores it in `executedCommands` to facilitate undo capability for this command.
* `Model#rememberInverselyExecutedCommand(Command)` -- Remembers the given `Command` and stores it in `inverselyExecutedCommands` to facilitate redo capability for this command.
* `Model#rollback()` -- Inversely executes the latest command stored in `executedCommands` to revert the changes of the latest executed command made onto `Model`.
* `Model#commit()` -- Executes the latest undone command stored in `inverselyExecutedCommands` to reapply the changes that were made onto `Model` by the latest undone command.

Commands support the given operations to mutate the state of the `Model` and to check if they should be stored for undo/redo function:

* `Command#hasInverseExecution()` -- Checks if the command's execution mutates the state of the `Model`, which is used to determine if the command should be remembered by `HistoryManager`.
* `Command#execute(Model)` -- Executes the command on the given `Model`.
* `Command#executeInverse(Model)` -- Executes on the given `Model` such that it will undo whatever changes were made when `Command#execute(Model)` was called.

Below is a class diagram between `Model`, `ModelManager`, `HistoryManager`, `CommandDeque` and `Command`.

.Class Diagram for `Model`, `ModelManager`, `HistoryManager`, `CommandDeque` and `Command`
image::HistoryManagerClassDiagram.png[]

Undo and redo operations are executed with `UndoCommand` and `RedoCommand`. These commands store an integer value referencing the number of commands to undo or redo,
represented by `UndoCommand#numberOfTimes` and `RedoCommand#numberOfTimes`. The Class Diagram below shows details about `UndoCommand` and `RedoCommand`.

.Class Diagram for `UndoCommand`, `RedoCommand` and `Command`
image::UndoRedoCommandClassDiagram.png[]

Below is a Sequence Diagram of how an `UndoCommand` executes in the program. `RedoCommand` follows a similar process.

.Sequence Diagram for `UndoCommand`
image::UndoSequenceDiagram.png[]

Given below is an example usage scenario of how undo/redo mechanism behaves.

Step 1. The user launches the application for the first time. The `HistoryManager` is initialized.
`HistoryManager#executedCommands` and `HistoryManager#inverselyExecutedCommands` are empty.

Step 2. The user executes `delete 5` command to delete the 5th person in the address book.
A `DeleteAddressCommand` is created and executed in `LogicManager#execute(String)`.
Since `DeleteCommand` is an invertible command, `HistoryManager` remembers the command, adding it to `HistoryManager#executedCommands`.

Step 3. The user executes `add n/David ...` to add a new person.
A `AddAddressCommand` is created and executed in `LogicManager#execute(String)`.
Since `AddAddressCommand` is an invertible command, `HistoryManager` remembers the command, adding it to `HistoryManager#executedCommands`.

[NOTE]
If a invertible command execution fails, `HistoryManager` will not remember it, therefore it will not be stored for undo/redo capabilities.

Step 4. The user now decides that the last two commands entered was a mistake, and decides to undo those commands by executing the `undo` command by typing in the command `undo r/2`.
An `UndoCommand` is created and executed in `LogicManager#execute(String)` to undo the latest two commands.
The command will call `Model#rollback()` two times. During each `Model#rollback()` call, the `Model` will call `HistoryManager` to take the latest command
from `HistoryManager#executedCommands` and call `Command#executeInverse(Model)` on the `Model`, undoing the changes made to `Model` by the command, before adding it to
`HistoryManager#inverselyExecutedCommands`. After the `undo` command execution is complete, the `Model` state is reverted to what it was before the two undone commands were executed.

[NOTE]
`undo`/`redo` commands can undo/redo one or more commands. To undo/redo one command, entering `undo`/`redo` is equivalent to entering  `undo 1`/`redo 1`.

[NOTE]
If an `undo`/`redo` command is given to undo/redo more commands than available, the operation will fail and no `undo`/`redo` is applied at all.
This check is enforced by `Model#getAvailableNumberOfExecutedCommands()`, `Model#getAvailableNumberOfInverselyExecutedCommands()`, `Model#canRollback()` and `Model#canCommit()`.

Step 5. The user then decides to execute the command `list`. `list` command is a *non-invertible command*. Therefore, it will not be stored by `HistoryManager` after its execution.

Step 6. The user decides to redo the last command that was undone by executing a `redo` command by typing in the command `redo`.
A `RedoCommand` is created and executed in `LogicManager#execute(String)` to redo the latest undo.
The command will call `Model#commit()` once. `Model` will call `HistoryManager` to take the latest command from `HistoryManager#inverselyExecutedCommands`
and call `Command#execute(Model)` on the `Model`, reapplying the changes that were made by the command, before adding it to `HistoryManager#executedCommands`.
After the `redo` command execution is complete, the `Model` has the changes made by the latest the command that was redone.

Step 7. The user executes `add n/John ...` to add a new person.
A `AddAddressCommand` is created and executed in `LogicManager#execute(String)`.
The `HistoryManager` clears all commands stored in `HistoryManager#inverselyExecutedCommands`.
Similar to `Step 3`, `HistoryManager` remembers this command.

[NOTE]
Whenever a new invertible command is executed that is not currently in `HistoryManager`, it will clear all the commands that are stored in `HistoryManager#inverselyExecutedCommands`.
This means that all potential redo actions are cleared.

==== Design Considerations
===== Aspect: How undo & redo executes
* *Alternative 1:* Saves the entire `Model`.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* *Alternative 2:* Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.

===== Aspect: Data structure to support the undo/redo commands
* *Alternative 1:* Use a `List` to store the history of `Model` states.
Maintain a pointer to point to the current version of `Model`, and shift the pointer along the list to facilitate undo/redo operations.
** Pros: Simple implementation.
** Cons: Expensive on storage as multiple copies of `Model` is stored.
* *Alternative 2:* Implement invertible commands whereby they support their inverse execution. Use two `Deque` data structures to store the history of commands, to represent
executed commands and inversely executed commands. Move commands from one deque to another and executing/inversely executing them to facilitate undo/redo operations.
** Pros: Storage efficient, as application only needs to keep track of invertible commands, and do not need to store multiple copies of `Model`.
** Cons: Implementation is more complex.

// end::undoredo[]

// tag::courseplanner[]

=== Course Planner feature

==== Overview
The Course Planner feature allows the user to track what courses they have
taken, are taking and plan out what they would want to take after the current
semester. The program offers updated information on courses offered by NUS,
along with convenient add, delete and check operations on their course list.

==== Implementation

The Course Planner feature closely follows the extendable OOP solution already
implemented within AB3. In the Course Planner, the `CoursePlanner` object
manages all aspects related to this feature. The course list of the user is
stored internally using a `UniqueCourseList` object, providing an abstraction
with `add`, `delete` and `getList` operations that are called by
`CoursePlanner`.

* `Model#getCoursePlanner()` - Gets the `CoursePlanner` instance
* `Model#lookUpCourse(Course)` - Looks up a course's information
* `Model#addCourse(Course)` - Adds a course to the user's list
* `Model#addCourse(Index, Course)` - Adds a course to the user's list at the
specified index
* `Model#deleteCourse(Course)` - Deletes the given Course from the user's list
* `Model#hasCourse(Course)` - Checks if the user has this course in their list
* `Model#getUnfilteredCourseList()` - Returns an `ObservableList` containing
the user's list of courses.

===== Course Datasets

Course datasets are taken directly from the {nus-mods-api}[NUSMods API]. They
conveniently store their data used on their website using the `.json` file
format. Therefore, all course data within the program are read directly from
`.json` files using the Jackson JSON API.

Each course, and their data, are given its own file. These files are laid out
in a `/modinfo` directory within the `resources` folder to be easily
accessible by the program.

A sample `.json` is given below for a fictional course `AB1234`.

[JSON]
----
{
    "courseCode": "AB1234",
    "courseCredit": "4",
    "description": "Course description for AB1234.",
    "faculty": "A Faculty in NUS",
    "fulfillRequirements": [
        "AB2234"
    ],
    "preclusion": "AB1231, AB1232",
    "prereqTree": {
        "and": [
            {
                "or": [
                    "CD1111",
                    "XY2222"
                ]
            },
            "EF3333"
        ]
    },
    "title": "Course AB1234's title"
}
----

The current codebase requires that every course datafile **must** have the
following attributes:

* `courseCode`
* `courseCredit`
* `title`
* `faculty`
* `description`

These attributes are *non-nullable*, as fro the 11000+ course datafiles
downloaded from NUSMods, all at least have these attributes. The other three:
`fulfillRequirements`, `preclusion` and `prereqTree` are optional/nullable
attributes.

[NOTE]
NUSMods is a popular website officially affiliated with NUS, where
students are able to look up information about courses and plan their
school timetable.

==== And-Or Tree

===== Overview

The `AndOrTree` is a tree data structure served by the `andor` package that
provides an abstraction for processing the prerequisite tree. The prerequisite
tree (henceforth referred to as `prereqTree`) is an attribute of a `Course`
that is available in the NUSMod's course dataset.

In order to show the user whether they are able to take a course, we use this
`prereqTree` attribute that is checked against the user's list of taken courses.
The `prereqTree` can be either:

1. empty - no prerequisites needed for this course
2. consist of one element only - only one course is a prerequisite
3. a nested `json` object - complex prerequisites

In the most complex case, `prereqTree` will be a nested `json` object
with object keys being either strings `"and"` or `"or"`, while array or
individual elements mappable strings. The program reads this nested `json`
object as a string and processes it to form the tree data structure.

An example of a processable json string is as such:
----
"prereqTree": {
    "and": [
        {
            "or": [
                "CD1111",
                "XY2222"
            ]
        },
        "EF3333"
    ]
}
----

This is compressed to

`"prereqTree": {"and": [{"or": ["CD1111", "XY2222"]},"EF3333"]}"`

===== Methods of the `AndOrTree` class

The following are `public` methods in `AndOrTree`.

* `AndOrTree#buildTree(String, jsonString, Function)`
+
Builds a tree from the given jsonString. `Function` is a mapper function
that processes a `String` returns a value of type `R`, where `R` is the
type of data stored by each node in the tree.

* `AndOrTree#fulfills(Collection)`
+
Checks if the given `Collection` fulfills the condition specified by this tree.
`AndOrNode` has its own corresponding `fulfill` that checks its children or
data against `Collection`

Due to the arbitrary ordering of the tree, `insert()` and `delete()`
operations commonly found in implementations of standard, ordered trees are
difficult to implement. Instead, the tree is fully created upon the call to
`buildTree()` and is then enforced to be immutable once built.

Each node in the tree of type `T` is represented by an `AndOrNode<T>`. Every
node can either  of these types:

1. `AND` - any subset of elements in a `Collection<T>` must match all children
of this node
2. `OR` - any element in a `Collection<T>` must match at least one of the
children of this node
3. `DATA` - any element in a  `Collection<T>` must match the data stored in
this node

The following diagram shows the conditions for which
`AndOrNode#fulfills(Collection)` returns `true` or `false`.

.AndOrNode Condition Diagram
image::AndOrNodeConditionDiagram.png[700,700,align=center]

The tree is built recursively using the Jackson JSON API's `JsonNode` class,
which along with `ObjectMapper()` that can read `json` strings, lets us
traverse the `json` object tree structure.

The sequence diagram of the tree building process is shown below:

.AndOrTree Sequence Diagram
image::AndOrSequenceDiagram.png[align=center]

The class looks at each node - checks if its a json Object, json Array or
a String, and does the appropriate actions and method calls to build the tree.

Other ways of building the tree can be easily extended by overloading the
`buildTree` method. However, this will not override the immutable properties
of the tree.

==== Design Considerations

===== Aspect: Storing of Course datasets

* Alternative 1 (current choice): Storing each course as its own file

** Pros:
+
Fast lookup as the contents of 11000+ files worth of data do not need
to be scanned directly. Concatenating file paths directly to the file
is used instead.

** Cons:
+
Difficult to manage. If we want to modify the datasets in any way, a script
will have to be written to process every file in the dataset.

* Alternative 2: Storing each course in one, large JSON file
** Pros:
+
Easier to manage. Every course can be found in a single file.

** Cons:
+
A large file will be difficult to view for a developer. It will also have
a slow performance as the entire file would have to be processed to look up
one course.

We ultimately went with alternative #1 as once the files were downloaded and
processed, there was no need to modify them any further. Manual lookup of
information about a specific  course during development is also much easier
with such a method.

===== Aspect: `AndOrTree` of fixed type vs `AndOrTree<R>` of generic type `R`

* Alternative 1 (current choice): `AndOrTree` with generics
** Pros
+
This makes the tree reusable in the future. The tree will also be able to
store any data-type which allows for easier unit testing, since it won't be
dependent on the correctness of the fixed data-type (`Course` in this
instance), and instead well-tested libraries such as Java's `String` API can
be used to test the class instead.

** Cons
+
Due to how the tree is built (i.e from a json string), a
**mapper function** must be passed into the `buildTree()` method to process the
string in each node to the generic type of the tree. The function is of a type
`Function<? super String, ? extends R>`, for a tree of type `R`.

* Alternative 2: `AndOrTree` dependent on `Course` (or any fixed datatype)
** Pros
+
There is no need to pass any mapper function into the `buildTree()` method as
the class will already know how to map each `String` to a type `R`. This
makes handling exceptions easier as they can be handled directly by the class
instead of by the caller.

** Cons
+
This increases coupling between the tree and the fixed data-type used by
the tree, resulting the correctness of the `AndOrTree` class being dependent
on the fixed data-type, as there will be no way to stub it.
The tree will also only be locked to a specific data-type and is
non-extendable.

We picked alternative #1 as its benefits far outweigh its disadvantages. While
extendability and resusability of the class is a nice bonus, the decrease in
coupling and increase in testability was the deciding factor in choosing
between these two approaches.

// end::courseplanner[]

// tag::planner[]
=== Planner Feature

==== Overview

The planner feature in JARVIS enables users to easily organise and manage their different
tasks in school. Users will be able to keep track of tasks they have done, and tasks they
have yet to do.

There are three types of tasks in the planner:

* `Todo`: Tasks with a description only
* `Event`: Tasks with a start and end date
* `Deadline`: Tasks with a due date

Users can `Tag` these tasks to sort them into different categories, as well as add `Priority` and
`Frequency` levels to them.

==== Implementation

The `Planner` contains a `TaskList`, which in turn, contains a number of tasks a user has. A simple
outline of the `Planner` can be seen in Fig 11 below.

.Overview of the entire Planner
image::plannermodel.png[align=left]

JARVIS' `Model` extends `PlannerModel` which facilitates all operations necessary to carry out commands
by the user.

* `Model#getPlanner()` -- Returns an instance of a `Planner`.

* `Model#addTask(int zeroBasedIndex, Task task` -- Adds a `Task` to the planner at the specified `Index`.

* `Model#addTask(Task t)` -- Adds a `Task` to the `Planner`. Since no `Index` is specified, the `Task` is
appended to the end of the `TaskList`.

* `Model#deleteTask(Index index)` -- Deletes the `Task` at the specified `Index` from the `Planner`.

* `Model#deleteTask(Task t)` -- Deletes the specified `Task` from the `Planner`.

* `Model#size()` -- Returns the total number of `Task` objects in the `Planner`.

* `Model#hasTask(Task t)` -- Checks if a given `Task` is already in the `Planner`.

* `Model#getTasks()` -- Returns the `TaskList` in the `Planner`.


==== Design Considerations

===== Aspect: Task Descriptions in a Task
* **Alternative 1 (Current choice):** As a string attribute in `Task`
** Pros: Intuitive, easy to implement, less code required
** Cons: Provides a lower level of abstraction, especially when `edit-task` command is implemented

* **Alternative 2:** Building a separate `TaskDescription` class
** Pros: Higher level of abstraction
** Cons: More code, will take time to replace current methods that deal with String `TaskDes` directly

// end:: planner[]

// tag::dataencryption[]
=== [Proposed] Data Encryption

_{Explain here how the data encryption feature will be implemented}_

// end::dataencryption[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* NUS student
* plans his own modules
* prefers typing over mouse input
* can type fast
* is reasonably comfortable using CLI apps
* has to manage a significant number of tasks
* has a tight budget

*Value proposition*: optimised for NUS students who have busy schedules and a tight budget

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a(n) ... |I want to ... |So that I can...
|`* * *` |social student |keep track of who owes me money & how much | not have anyone owe me any money.

|`* * *` |busy student |keep track of all the tasks I have done | work on tasks that I have yet to do.

|`* * *` |indecisive student |roll back and forth changes that I have done | track my ever-changing schedule.

|`* * *` |NUS student | view all the prerequisites for a specified module | plan my academic roadmap accordingly.

|`* *` |busy student |be reminded when I am nearing a deadline |be on top of all my assignments

|`*` |student |calculate my CAP easily |keep track of my progress in university.
|=======================================================================

[appendix]
== Use Cases

(For all use cases below, the *System* is the `JARVIS` and the *Actor* is the `user`, unless specified otherwise)
[discrete]
=== Use case: Set tabs in finance tracker

*MSS*

1. User inputs amount paid and the names of people who he paid for
2. JARVIS calculates equal tab for all names including user
3. JARVIS stores individual tabs for names input
4. JARVIS prompts user that tabs have been added
5. User requests to see list of debts owed to him
6. JARVIS shows list of debts
+
Use case ends.

[discrete]
=== Use case: Marks task in planner as done

*MSS*

1. User requests to list tasks in planner
2. JARVIS shows lists of tasks in planner
3. User requests to mark a certain task as done
4. JARVIS finds task and marks it as done
+
Use case ends.

*Extensions*

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

[discrete]
=== Use case: Undo previous command

*MSS*

1. User adds a project meeting into planner
2. JARVIS adds meeting into planner
3. User requests to undo project meeting
4. JARVIS rolls backs back the command
+
Use case ends.

[discrete]
=== Use case: View prerequisite tree

*MSS*

1. User requests to for the prerequisite tree of a certain module
2. JARVIS shows the prerequisite tree
+
Use case ends.

*Extensions*

* 2a. The given module code is invalid
+
[none]
** 2a1. AddressBook shows an error message.
+
Use case resumes at step 1.

[appendix]
== Non Functional Requirements

.  JARVIS should work on any mainstream OS as long as it has Java 12 or above installed.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  JARVIS should respond within two seconds.
.  JARVIS should be usable by a novice who has never used a command line interface.
.  JARVIS should be able to work without any internet connection.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[CLI]] CLI::
Command Line Interface

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
